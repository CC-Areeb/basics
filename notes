"Few Routing ways"


We can use prefixes to set the prefix of a route name and group all the routes that 
are starting with the same URL point inside that group as shown below

"
Route::prefix('/test')->group(function() {
    Route::get(/, [TestController::class, 'test_index']);
    Route::get(/blog, [TestController::class, 'test_create']);
    Route::get(/blog/{id}/edit, [TestController::class, 'test_edit']);
});
"

We can also use fallback routes so that when user are trying to access incorrect routes
they will always be redirected to either the home page or the dashboard or the login page
as shown below

"
Route::fallback(FallbackController::class);
"

you can also call in the function inside directly as well as shown below

"
Route::fallback('/login', function(){
    return view(login);
})
"

I chose to use the controller and inside the controller I have an invoke method 
as shown below

"
public function __invoke()
    {
        return view('welcome');
    }
"
The invoke method is a special function inside laravel which is used in single action
controllers.

You can generate an invokable controller by using the --invokable option

"
php artisan make:controller ProvisionServer --invokable
"


"Seeders"

Seeders are used to pass in correct data inside the database, the seeder file is made
when you create the migration throught the terminal and add the -s flag as seeder
the DatabaseSeeder is the main seed file that is used. The other seeder that we made will
only contain the data in an array and then it will passed in the DatabaseSeeder file inside
the run method "$this->call(TestSeeder::class);"

Next we need to loop the data and interact with the database system of laravel and for that 
we will use the Laravel Eloquent Model system instead of Query Builder as Eloquent makes it 
a bit easier to understand and write the queries using keywords like "create(), update(), delete()"
etc ...

We will be using the foreach loop as shown below

"
[
    'title' => 'Post one',
    'excerpt' => 'Summery of Post one',
    'body' => 'Body of Post one',
    'minutes_to_read' => 5,
    'image_path' => 'Empty',
    'is_published' => false,
]

foreach ($posts as $key => $value) {
    Post::create($value);
}   
"

Since we only want the values so we will only pass in the "$value" inside the create method.

Now inside the DatabaseSeeder file ----> inside the run method -----> we will call our 
"PostSeeder" by using the "this" global access keyword as shown below

"$this->call(PostSeeder::class);"


There are 2 ways to run seeders using the CLI/terminal.

1 - Running it with the migrations
"php artisan migrate --seed"

2 - Running it Seperatly
"php artisan db:seed"


"Model Factory"
When we are testing, we should not define each and every single rows like we did in seeders
instead we can use model factories that are used to insert dummy data one or more times.

Step 1 - Define a Factory class from the CLI
"php artisan make:factory TestFactory"

The factory you make will be inside the factory folder which is inside the database folder,
by default we have a defination method which will return an array as shown below

"
public function defination()
{
    return[
        //
    ];
}
"

NOTE :- Whenever we make a new laravel project, we get few things already made for us like
the User model, the users table with the fields, the user model factory with the data that
will be used inside the return array.

Since we define our operations inside the defination method, we will define our key value pairs
inside the return array as shown below

"
return [
    'key_1 => 'value_1',
    'key_2 => 'value_2',
];
"

The key name has to be exactly the same as the database field names that we have migrated,
the factory that I have made is shown below

"
return [
    'title' => 'Model factories',
    'excerpt' => 'Excerpt of our fist model factory',
    'body' => 'Body of our fist model factory',
    'minutes_to_read' => 5,
    'image_path' => 'Image Path',
    'is_published' => 1,
];
"

In this we are also defining static data like we did in seeders but the main difference is that we
can use faker instance for inserting different dummy data. Faker is a random data generator inside
laravel. Below is the example of the return array but instead using static data as shown above, we
will use the faker instance for generating data.


Some libraries we can use with faker (there are more)

"
random_int(0, 12300) ----> first number is the starting range and the second one is the ending range

Str::random(20) ------> any random string with lenght of 20

$faker->word ------> any random word

$faker->sentence -------> any random sentence

$faker->paragraph ---------> any random paragraph

$faker->randomFloat(2, 0, 10000) --------> any random float number starting from 0 till 10000 with 2 decimal places

$faker->image('public/storage/images',640,480, null, false), ------> fake image path with the dimensions like width and height

$faker->text(200) -----> random text with 200 characters

$faker->numberBetween(10, 500) --------> random number between 10 and 500, can be repeated

$faker->unique()->numberBetween(100, 500) --------> random number between 10 and 500, cannot be repeated

$faker->userName, -------> random person name

$faker -> sentence(4,true), ------> random 4 word sentence

"

More faker libraries inside the "vendor/fakerphp/faker/src/Faker/Generator.php" file


After defining our factory, we need to make sure that the data persists in the database so for that we 
we need to call in the Model and use the factory facade and this facade takes in a interger as its 
only parameter, this integer tells us how many dummy data we want to generate and insert in our table
inside the database. Also chain in the create() method in the end so that it can actually save the data
in the database.

"
TestMdoel::factory(5); --------> 5 is the number of data we need to generate for inserting in database
"

after this perform the database seeder command "php artisan db:seed"

We can also override a specific data generated by the factory by passing in an array and
defining a key value pair as shown below

"
Post::factory(20)->create([
    'body' => 'Overriding the body' -----> overriding the body text
]);
"



Laravel Query Builder

Query builder is used for interacting with the database like storing information
and displaying all or any data based on a condition. The first method is by using 
the laravel query builder.

To use query builder, we fisrt need to pull in its use facade called 
"use Illuminate\Support\Facades\DB;" ----> (ignore the color).

Facades are used so that we can use static methods to access non-static resources.
Whenever we want to access methods of the facade, we need to use double columns after
the facade class as shown below

"
DB::
"

After this we can then access the methods that are available inside this facade.
"
DB::available_method()
"

"DB::statement();" ---> the statement() is one of the many available methods used for 
query builder and this will accept a string or raw sql query. This will check of your
query is acceptable or not and will return a boolean "true" or "1".

Example of raw sql query :-

"
SELECT * FROM users
"

then you can display the output.

Full example :-
"
$test = DB::statement('SELECT * FROM users');
print_r($test);
die(); ----> used to end the compilation of code (optional)
return view('welcome');
"

Using the select statement in query builder will display the data that is available
in our database. The select method is shown Below

"
DB::select('select * from posts');
"

An important topic in coding is parameter binding or prepared statements. Laravel has
implemented PDO 

NOTE :-

PDO (PHP Data Objects) is an abstraction layer for your database queries and is
an awesome alternative to MySQLi, as it supports 12 different database drivers.
his is an immense benefit for people and companies that need it. However, keep
in mind that MySQL is by far the most popular database.


"Where clause"

"
DB::select('select * from posts where id = 1');
"
The where keyword is used to provide conditions so that the result is shown only when
the condition is met. However this is also not the best way to do things as this can 
lead to potential sql attacks.

The best way will be the placeholder where we will use the "?" as a placeholder and 
after the comma (,) we will pass an array with index of 1 which will dynamically return
the value of the first row from the database as shown below

"
DB::select('select * from users where id = ?', ['id' => 1]);

DB::select('select * from users where id = :id', ['id' => 1]);
"

You can replace the "?" with a named placeholder, the name should be equal to the name
of database column name for better understanding and consistancy.


NOTE :-
The sql keywords are not case sensitive so you can write them in small or all capital.  


"Insert clause"

We use this clause to actually submit data and save it in the database or server as shown below


"
DB::insert('insert into posts (title, excerpt, body, image_path, is_published, minutes_to_read, is_published)
        values
        (?, ?, ?, ?, ?, ?)', ['Test', 'test', 'test', 'test', true, 1]);
"

The first part of the query is where you define all your table tuples or column names, the next part is the 
keyword called "values", this ensures we are going to insert some data or values in the database.

We again went with the dynamically firing query by using the placeholders inside the values () parenthesis
and passing the array of data.


"Update clause"

We use this to update/edit the previously stored data as shown below

"
DB::update('update posts set body = :body where id = :id', ['body 2', 44]);
"

Update is a keyword then we select the table name, after that we will set the column name and set 
a placeholder for it, next we will use the where keyword and define any other column name with its
placeholder and then in the end we pass the array where we will pass in the data that we want to update


"Delete clause"

We use this to remove records from our database 

"
DB::delete('delete from posts where id = :id,' [40]);
"

The first part is the delete keyword that indicates that we are deleting something, next is the name 
of the table from which we are going to delete something, then we use the where clause so that we can 
check if that data actually exists in the first place or not.

These were the simple basic ones, next we will see some complex ones which involve the use of chaining 
different methods to perform the task.

"
DB::table('table_name')->get();
"

The get method is used for fetching the data that is stored in the database and display it to the screen,
the get method should always be in the end as it is the method used for actually displaying results after
other methods have fired their functions.


Other chaining methods include such as "select()" which will return back only the data we want to see as
shown below

"
$test = DB::table('posts')
            ->select('id')
            ->get();
        dd($test); ----> this laravel's way of writing var_dump(), this will dump the result and stop the compiler
                        after dumping
"

We can pass in multiple parameters inside the select method as well 

"
$test = DB::table('posts')
            ->select('id', 'title')
            ->get();
        dd($test);
"

Now we will chain the where method 

"
$test = DB::table('posts')
        ->where('id', '=', 5)
        ->get();
"

Inside this where method, we have 3 parameters. The fields are the name of the table and the comparison operator
or any other operations that we want to perform and the last is the value 

Adding the comparison operator will explicitly apply the desired comparison we are performing however if you do
not add it, then by default the operator will be set to "=".

"
$test = DB::table('posts')
        ->where('id', 5)
"

We can also pass in boolean as a value instead of integer or string

"
$test = DB::table('posts')
        ->where('is_published', true)
"

We can pass in multiple where methdos for more conditions.

"
$test = DB::table('posts')
        ->where('is_published', true)
        ->where('id', '>', 10)
        ->get();        
dd($test);
"

To summerize, there are many methdos available for the query builder facade and we need the docs to see them
all.


"Laravel Blade"

First we can use the query builder chaining method to get all the data from the database and store it inside a
variable as shown below

"
$posts = DB::table('posts')->get();
"

We are using the get method as it will fetch us the data. Next we can chain the "with()" method where we are
returning the view so that we can also display the data inside that view as shown below

"
return view('blog.welcome')->with('posts', $posts);
"

The "with()" method accepts a key value pair, so in the quotations we are defining the key so for my case I am
naming my key "posts" and then the value will be the data we are getting from the dataabse and storing it in the
variable "$posts"

To make things fairy easy, we can replace the get method with find method which needs a value and it will find us
that data according to the argument it has as shown below

"
$posts = DB::table('posts')->find(1);
"

NOTE :- 
When we use the find method, it only accepts the id and nothing else, it will return "null" if you pass in a string 
or somehting that is not an "id".

Now we will display the result that we have stored in the variable in the blade template so that it can be displayed 
as an actuall output.

To use this, we need to wrap our variable inside the double set of curly braces " {{  }} " and then we can access the
value that we have set inside the with method as shown below

"
{{ $posts }}
"

Here we can use the pointer or access operator " -> " and with this we can access any column of the database we want
to show

"
{{ $posts -> id }}
"

NOTE :-

The " {{  }} " we use are just a syntax and what is actually happening is shown below

"
<?php echo htmlentites($posts->id) ?>
"

This protects the users from scripting attacks 

We can use the "compact()" method which returns an array to the view and is a php function.
This works a bit differently. You need to pass the "compact()" method inside the "view()"
method as the second parameter and pass in the table name that you have defined in your
query builder table parameter as shown below

"
return view(blog.welcome, compact('posts'));
"

Then we can use the double set of braces "{{  }}" and use the dump method to see the raw
output as shown below

"
{{ dump($posts) }}
"

Finally a better way is to simply pass an array of key value pair and make sure that the key
name is equal to the variabel which is storing fetch results of your query as shown below

"
$posts = DB::table('posts')->get();
return view('blog.welcome', [
    'posts' => $posts,
]);
"

If you want to shorten your code then you can also skip the variable part and just directly
pass the query as the value inside the array as shown below

"
return view('blog.welcome', [
    'posts' => DB::table('posts')->get(),
]);
"


"Blade directives"

These are helpers provided in laravel where we can perform some properties like conditional
statements and write php codes in between our html code or blade syntax. There are many blade
syntax or snippets we can use.

NOTE :-
If you are using VS code then it is better that you install intellisenses for laravel and others
to make coding a bit eaiser in terms of syntax.

To write use these blade directives, first we write the at symbol "@" and then the keywords.

Sample blade directives shown below

"
@if (count($posts) > 21)
    {{ dump('Yes') }}
@else
    {{ dump('Nope') }}
@endif
"

"
@if (count($posts) < 1)
    {{ 'text' }}
@elseif (count($posts) > 0)
    {{ 'text' }}
@else
    {{ 'text' }}
@endif
"

"
@unless (!$posts)
    <h1>okay</h1>
@endunless
"

The "unless" directive is the opposite of "if" directive that's why the output will be displayed when used
with the "!" symbols inside the "@unless()".

"
@foreach ($posts as $post)
    <h1>All posts</h1>
@endforeach
"

The "foreach" and "forelse" is almost similar but the difference is that with the forelse we have a fallback
option when the object is empty.

