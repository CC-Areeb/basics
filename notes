"Few Routing ways"


We can use prefixes to set the prefix of a route name and group all the routes that 
are starting with the same URL point inside that group as shown below

"
Route::prefix('/test')->group(function() {
    Route::get(/, [TestController::class, 'test_index']);
    Route::get(/blog, [TestController::class, 'test_create']);
    Route::get(/blog/{id}/edit, [TestController::class, 'test_edit']);
});
"

We can also use fallback routes so that when user are trying to access incorrect routes
they will always be redirected to either the home page or the dashboard or the login page
as shown below

"
Route::fallback(FallbackController::class);
"

you can also call in the function inside directly as well as shown below

"
Route::fallback('/login', function(){
    return view(login);
})
"

I chose to use the controller and inside the controller I have an invoke method 
as shown below

"
public function __invoke()
    {
        return view('welcome');
    }
"
The invoke method is a special function inside laravel which is used in single action
controllers.

You can generate an invokable controller by using the --invokable option

"
php artisan make:controller ProvisionServer --invokable
"


"SEEDERS"

Seeders are used to pass in correct data inside the database, the seeder file is made
when you create the migration throught the terminal and add the -s flag as seeder
the DatabaseSeeder is the main seed file that is used. The other seeder that we made will
only contain the data in an array and then it will passed in the "DatabaseSeeder" file inside
the run method "$this->call(TestSeeder::class);"

Next we need to loop the data and interact with the database system of laravel and for that 
we will use the Laravel Eloquent Model system instead of Query Builder as Eloquent makes it 
a bit easier to understand and write the queries using keywords like "create(), update(), delete()"
etc ...

We will be using the foreach loop as shown below

"
[
    'title' => 'Post one',
    'excerpt' => 'Summery of Post one',
    'body' => 'Body of Post one',
    'minutes_to_read' => 5,
    'image_path' => 'Empty',
    'is_published' => false,
]

foreach ($posts as $key => $value) {
    Post::create($value);
}   
"

Since we only want the values so we will only pass in the "$value" inside the create method.

Now inside the DatabaseSeeder file ----> inside the run method -----> we will call our 
"PostSeeder" by using the "this" global access keyword as shown below

"$this->call(PostSeeder::class);"


There are 2 ways to run seeders using the CLI/terminal.

1 - Running it with the migrations
"php artisan migrate --seed"

2 - Running it Seperatly
"php artisan db:seed"


"Model Factory"
When we are testing, we should not define each and every single rows like we did in seeders
instead we can use model factories that are used to insert dummy data one or more times.

Step 1 - Define a Factory class from the CLI
"php artisan make:factory TestFactory"

The factory you make will be inside the factory folder which is inside the database folder,
by default we have a defination method which will return an array as shown below

"
public function defination()
{
    return[
        //
    ];
}
"

NOTE :- Whenever we make a new laravel project, we get few things already made for us like
the User model, the users table with the fields, the user model factory with the data that
will be used inside the return array.

Since we define our operations inside the defination method, we will define our key value pairs
inside the return array as shown below

"
return [
    'key_1 => 'value_1',
    'key_2 => 'value_2',
];
"

The key name has to be exactly the same as the database field names that we have migrated,
the factory that I have made is shown below

"
return [
    'title' => 'Model factories',
    'excerpt' => 'Excerpt of our fist model factory',
    'body' => 'Body of our fist model factory',
    'minutes_to_read' => 5,
    'image_path' => 'Image Path',
    'is_published' => 1,
];
"

In this we are also defining static data like we did in seeders but the main difference is that we
can use faker instance for inserting different dummy data. Faker is a random data generator inside
laravel. Below is the example of the return array but instead using static data as shown above, we
will use the faker instance for generating data.


Some libraries we can use with faker (there are more)

"
random_int(0, 12300) ----> first number is the starting range and the second one is the ending range

Str::random(20) ------> any random string with lenght of 20

$faker->word ------> any random word

$faker->sentence -------> any random sentence

$faker->paragraph ---------> any random paragraph

$faker->randomFloat(2, 0, 10000) --------> any random float number starting from 0 till 10000 with 2 decimal places

$faker->image('public/storage/images',640,480, null, false), ------> fake image path with the dimensions like width and height

$faker->text(200) -----> random text with 200 characters

$faker->numberBetween(10, 500) --------> random number between 10 and 500, can be repeated

$faker->unique()->numberBetween(100, 500) --------> random number between 10 and 500, cannot be repeated

$faker->userName, -------> random person name

$faker -> sentence(4,true), ------> random 4 word sentence

"

More faker libraries inside the "vendor/fakerphp/faker/src/Faker/Generator.php" file


After defining our factory, we need to make sure that the data persists in the database so for that we 
we need to call in the Model and use the factory facade and this facade takes in a interger as its 
only parameter, this integer tells us how many dummy data we want to generate and insert in our table
inside the database. Also chain in the create() method in the end so that it can actually save the data
in the database.

"
TestMdoel::factory(5)->create(); --------> 5 is the number of data we need to generate for inserting in database
"
The "create()" keyword is responsible for actually storing data in database and after this perform the
database seeder command "php artisan db:seed"

We can also override a specific data generated by the factory by passing in an array and
defining a key value pair as shown below

"
Post::factory(20)->create([
    'body' => 'Overriding the body' -----> overriding the body text
]);
"



Laravel Query Builder

Query builder is used for interacting with the database like storing information
and displaying all or any data based on a condition. The first method is by using 
the laravel query builder.

To use query builder, we fisrt need to pull in its use facade called 
"use Illuminate\Support\Facades\DB;" ----> (ignore the color).

Facades are used so that we can use static methods to access non-static resources.
Whenever we want to access methods of the facade, we need to use double columns after
the facade class as shown below

"
DB::
"

After this we can then access the methods that are available inside this facade.
"
DB::available_method()
"

"DB::statement();" ---> the statement() is one of the many available methods used for 
query builder and this will accept a string or raw sql query. This will check of your
query is acceptable or not and will return a boolean "true" or "1".

Example of raw sql query :-

"
SELECT * FROM users
"

then you can display the output.

Full example :-
"
$test = DB::statement('SELECT * FROM users');
print_r($test);
die(); ----> used to end the compilation of code (optional)
return view('welcome');
"

Using the select statement in query builder will display the data that is available
in our database. The select method is shown Below

"
DB::select('select * from posts');
"

An important topic in coding is parameter binding or prepared statements. Laravel has
implemented PDO 

NOTE :-

PDO (PHP Data Objects) is an abstraction layer for your database queries and is
an awesome alternative to MySQLi, as it supports 12 different database drivers.
his is an immense benefit for people and companies that need it. However, keep
in mind that MySQL is by far the most popular database.


"Where clause"

"
DB::select('select * from posts where id = 1');
"
The where keyword is used to provide conditions so that the result is shown only when
the condition is met. However this is also not the best way to do things as this can 
lead to potential sql attacks.

The best way will be the placeholder where we will use the "?" as a placeholder and 
after the comma (,) we will pass an array with index of 1 which will dynamically return
the value of the first row from the database as shown below

"
DB::select('select * from users where id = ?', ['id' => 1]);

DB::select('select * from users where id = :id', ['id' => 1]);
"

You can replace the "?" with a named placeholder, the name should be equal to the name
of database column name for better understanding and consistancy.


NOTE :-
The sql keywords are not case sensitive so you can write them in small or all capital.  


"Insert clause"

We use this clause to actually submit data and save it in the database or server as shown below


"
DB::insert('insert into posts (title, excerpt, body, image_path, is_published, minutes_to_read, is_published)
        values
        (?, ?, ?, ?, ?, ?)', ['Test', 'test', 'test', 'test', true, 1]);
"

The first part of the query is where you define all your table tuples or column names, the next part is the 
keyword called "values", this ensures we are going to insert some data or values in the database.

We again went with the dynamically firing query by using the placeholders inside the values () parenthesis
and passing the array of data.


"Update clause"

We use this to update/edit the previously stored data as shown below

"
DB::update('update posts set body = :body where id = :id', ['body 2', 44]);
"

Update is a keyword then we select the table name, after that we will set the column name and set 
a placeholder for it, next we will use the where keyword and define any other column name with its
placeholder and then in the end we pass the array where we will pass in the data that we want to update


"Delete clause"

We use this to remove records from our database 

"
DB::delete('delete from posts where id = :id,' [40]);
"

The first part is the delete keyword that indicates that we are deleting something, next is the name 
of the table from which we are going to delete something, then we use the where clause so that we can 
check if that data actually exists in the first place or not.

These were the simple basic ones, next we will see some complex ones which involve the use of chaining 
different methods to perform the task.

"
DB::table('table_name')->get();
"

The get method is used for fetching the data that is stored in the database and display it to the screen,
the get method should always be in the end as it is the method used for actually displaying results after
other methods have fired their functions.


Other chaining methods include such as "select()" which will return back only the data we want to see as
shown below

"
$test = DB::table('posts')
            ->select('id')
            ->get();
        dd($test); ----> this laravel's way of writing var_dump(), this will dump the result and stop the compiler
                        after dumping
"

We can pass in multiple parameters inside the select method as well 

"
$test = DB::table('posts')
            ->select('id', 'title')
            ->get();
        dd($test);
"

Now we will chain the where method 

"
$test = DB::table('posts')
        ->where('id', '=', 5)
        ->get();
"

Inside this where method, we have 3 parameters. The fields are the name of the table and the comparison operator
or any other operations that we want to perform and the last is the value 

Adding the comparison operator will explicitly apply the desired comparison we are performing however if you do
not add it, then by default the operator will be set to "=".

"
$test = DB::table('posts')
        ->where('id', 5)
"

We can also pass in boolean as a value instead of integer or string

"
$test = DB::table('posts')
        ->where('is_published', true)
"

We can pass in multiple where methods for more conditions.

"
$test = DB::table('posts')
        ->where('is_published', true)
        ->where('id', '>', 10)
        ->get();        
dd($test);
"

To summerize, there are many methods available for the query builder facade and we need the docs to see them
all.


"Laravel Blade"

First we can use the query builder chaining method to get all the data from the database and store it inside a
variable as shown below

"
$posts = DB::table('posts')->get();
"

We are using the get method as it will fetch us the data. Next we can chain the "with()" method where we are
returning the view so that we can also display the data inside that view as shown below

"
return view('blog.welcome')->with('posts', $posts);
"

The "with()" method accepts a key value pair, so in the quotations we are defining the key so for my case I am
naming my key "posts" and then the value will be the data we are getting from the dataabse and storing it in the
variable "$posts"

To make things fairy easy, we can replace the get method with find method which needs a value and it will find us
that data according to the argument it has as shown below

"
$posts = DB::table('posts')->find(1);
"

NOTE :- 
When we use the find method, it only accepts the id and nothing else, it will return "null" if you pass in a string 
or somehting that is not an "id".

Now we will display the result that we have stored in the variable in the blade template so that it can be displayed 
as an actuall output.

To use this, we need to wrap our variable inside the double set of curly braces " {{  }} " and then we can access the
value that we have set inside the with method as shown below

"
{{ $posts }}
"

Here we can use the pointer or access operator " -> " and with this we can access any column of the database we want
to show

"
{{ $posts -> id }}
"

NOTE :-

The " {{  }} " we use are just a syntax and what is actually happening is shown below

"
<?php echo htmlentites($posts->id) ?>
"

This protects the users from scripting attacks 

We can use the "compact()" method which returns an array to the view and is a php function.
This works a bit differently. You need to pass the "compact()" method inside the "view()"
method as the second parameter and pass in the table name that you have defined in your
query builder table parameter as shown below

"
return view(blog.welcome, compact('posts'));
"

Then we can use the double set of braces "{{  }}" and use the dump method to see the raw
output as shown below

"
{{ dump($posts) }}
"

Finally a better way is to simply pass an array of key value pair and make sure that the key
name is equal to the variable which is storing fetch results of your query as shown below

"
$posts = DB::table('posts')->get();
return view('blog.welcome', [
    'posts' => $posts,
]);
"

If you want to shorten your code then you can also skip the variable part and just directly
pass the query as the value inside the array as shown below

"
return view('blog.welcome', [
    'posts' => DB::table('posts')->get(),
]);
"


"Blade directives"

These are helpers provided in laravel where we can perform some properties like conditional
statements and write php codes in between our html code or blade syntax. There are many blade
syntax or snippets we can use.

NOTE :-
If you are using VS code then it is better that you install intellisenses for laravel and others
to make coding a bit eaiser in terms of syntax.

To write use these blade directives, first we write the at symbol "@" and then the keywords.

Sample blade directives shown below

"
@if (count($posts) > 21)
    {{ dump('Yes') }}
@else
    {{ dump('Nope') }}
@endif
"

"
@if (count($posts) < 1)
    {{ 'text' }}
@elseif (count($posts) > 0)
    {{ 'text' }}
@else
    {{ 'text' }}
@endif
"

"
@unless (!$posts)
    <h1>okay</h1>
@endunless
"

The "unless" directive is the opposite of "if" directive that's why the output will be displayed when used
with the "!" symbols inside the "@unless()".

"
@foreach ($posts as $post)
    <h1>All posts</h1>
@endforeach
"

The "foreach" and "forelse" is almost similar but the difference is that with the forelse we have a fallback
option when the object is empty.

"
@forelse ($posts as $post)
    {{ $post->title }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

In the forelse loop we have a fallback that runs a different code block when the loop condition is not met.


There are some hidden properties we can use with the "foreach" and the "forelse" loop.

the first example is "$loop->index". The "$loop" is an "StdClass" and the index method will return the item that
has the index of 0

"
@forelse ($posts as $post)
    {{ $loop->index }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We can replace the index with iteration and this will skip the 0 index and return everything else.

"
@forelse ($posts as $post)
    {{ $loop->iteration }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We can also use the remaining method and this will return all the values that are leftover

"
@forelse ($posts as $post)
    {{ $loop->remaining }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We can use the count method so that we can get the exact number of items in our database

"
@forelse ($posts as $post)
    {{ $loop->count }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

NOTE:- this "$loop" StdClass is only going to work when you have accessed your database inside
your blade directive

"
Controller :-

$posts = DB::table('posts')->get();
return view('blog.welcome', [
    'posts' => $posts,
]);

Blade :-

@forelse ($posts as $post)
    {{ $loop->count }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We can also use the "first" property and this is a boolean so this will tell if
this is the first item or not and will return 1 or 0 based on the result.

"
@forelse ($posts as $post)
    {{ $loop->first }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We also have the "last" property that checks for the last value inside the database

"
@forelse ($posts as $post)
    {{ $loop->last }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We also have the "depth" property for checking how many loops are being executed

"
@forelse ($posts as $post)
    {{ $loop->depth }}
@empty
    <p>Nothing here to see</p>
@endforelse
"

We also have the "parent" property that references the parent loop

"
@for ($posts = 0; $posts < $count; $posts++)
    @forelse ($posts as $post)
        {{ $loop->depth }}
    @empty
        <p>Nothing here to see</p>
    @endforelse
@endfor
"
the above is just a sample to show nested loops

"Eloquent Models"

This is one of the most important features of laravel and this is an active record optional
relational mapper and makes interacting with the database a lot easier.

Active record means that one eloquent class is responsible for interacting with 1 whole table 
as well as 1 table row.

"Create a model"

To make a model, we simply need to type the following command

"
php artisan make:model Test
"

Side note, we can also attach flags to the model command to include things like database table, controller,
factory, seeder and more

"-a" is a flag that will make all the relatable things like migration, seeder, controller, factory and much more

"-m" is a flag for migration and mostly used with models so that the model is already connected with that table

"-c" is a flag for making a controller 

"-mc" we can chain multiple flags like this to make the files that you need such as a migration and a controller.

Inside the model we can use some pre-defined variables to apply certain conditions for the model as shown below

" protected $table = 'tests'; "
laravel automatically applies snake casing so if you do not want to use plural forms then you can define your 
table like that.

" protected $primaryKey = ''; "
laravel models by default set the id as the primary key but if we want to change it then we can use this variable
and set our primary key so something else and has to be from the column names you have defined and inside the
single quotations

" $table->timestamps(); "
this is used so that we can add the "created_at" and "updated_at" columns when we migrate the database (it is optional)
but if you want to disble these, instead of deleting them, we can set the timestamps to be false. By default it is
always true

" protected $timestamps = false; "

We can also customize the timestaps that are added to our database 

" protected $dateFormat = 'U'; "
this will store the time in only seconds.

" protected $connection = 'sqlite'; "
we can also change our database driver for specific model and by using the $connection we can add another
driver just for this model

"
protected $attributes = [
    'key' => 'value',
];
"
we can use this to set values to a default value, this works similarly like the "defalult()" method but we can 
also do this in the model too.  


"Retrieving data from database"

inside our controller we can use the eloquent way of retrieving data.

"
$posts = Post::all();
dd($posts);
"
the "all()" method returns all the data that is inside the database

"
$posts = Post::get();
dd($posts);
"
alternativly we can use the "get()" method and this will do the same

NOTE:
the difference between "get()" and "all()" is that with "get()" we can apply multiple chaining methods whereas with "all()"
we cannot other chain methods so best if you always use "get()"

"
$posts = Post::first();
dd($posts);
"
we can change the "get()" with the "first()" method and this will only return the first row of the database and that's 
it.

"
$posts = Post::orderBy('id', 'desc')->take(5)->get();
dd($posts);
"
here we have chained in few methods like "orderBy()", "take()" as well as passed in their respective parameters and "get()"
will be in the end to display the results based on the conditions. The "take()" will show a perticular amount of records
and in this case it will show only 5 records in descending order (from the last to first).

Most of the time we will be using the where clause as this clause lets us apply condition and filter our result before we
display in the UI.

"
$posts = Post::where('minutes_to_read', 6)->get();
dd($posts);
"

We can also chain multiple where clauses as well to apply more than 1 condition

"
$posts = Post::where('minutes_to_read', 6)
            ->where('is_published', 1)
            ->get();
dd($posts);
"

We can also use the comparison operators as by default there is always an "=" equal comparison but we can also
pass in another argument in between the column name and the condition for different types of comparisions

"
$posts = Post::where('minutes_to_read', '!=' ,6)->get();
dd($posts);
"

now the where clause has 3 arguments, 1st is the column name, 2nd is the operator we want to use and the 3rd is the
filter or condition we are comparing our data with.

For very large amounts of data, it is wise to always break it down into chunks and then retrieve it

"
Post::chunk();
"
first parameter will be an interger which will define that how much row will be inside a single piece or "chunk"

"
Post::chunk(5, );
"
now we have to add a callback function inside the chunk method 

"
Post::chunk(5, function($posts){
    foreach ($posts as $post) {
        echo $post->title . '<br>';
    }
});
"
here we are using a foreach loop to print the whole data based on the chunks.
Chunking is used to get data in small peices per request.
We can also aggregated functions as well as shown below


"
dd(Post::get()->count());
"
we have used the count method in SQL and Query builder and we can also use this here when using the eloquent as well



Another aggregated function is the sum method 
"
dd(Post::sum('minutes_to_read'));
"

Another is the average method
"
dd(Post::avg('minutes_to_read'));
"


Usually we want to show all the data that is public inside the index function so when the user lands on that page,
they can see what info is stored based on the latest time stamps.
"
return view('blog.welcome', [
    'posts' => Post::orderby('created_at', 'desc')->get()
]);
"
Here we are passing the whole model as a value and assigning it a key and then we will use that key in the loop to
bring the whole data and display it in the screen.

"
@foreach ($posts as $post)
    {{ $post->id }}
@endforeach
"

We can also just display 1 data based on its id in the show method. To get the data from the database, we need to
make sure we are that we can do something with the $id variable.

"
dd(Post::find($id));
"
the find method only works with the $id variable and nothing else.

Now we also want to throw an exception when we are trying to find something that does not exist and hence we can use
the "findOrFail()" method and with this an exception will be given in the form of a 404 status code which means that
this item or data does not exist.

"THESE ARE THE DATABASE TUPLE NAMES THAT I AM WORKING WITH"

"
id 
title 
excerpt 
body 
minutes_to_read 
image_path 
is_published 
created_at 
updated_at 
"


"INSERTING DATA"
Now we will look at how to use eloquent to insert data into the database. Since we are using a resource controller then we
can use 2 functions that will allow us to first display the page where we can input out data and the other function will perform
the actual task of inserting the data in the database.

These 2 functions are called the "create()" method and the store "method()".
Firstly we need to make a naviagtion system where when we click button, we can go to the next page where there will be a forms
to do this we can just pass in the "route('blog.create')" in the anchor tag's href where it will navaigate when clicked.
"
<a class="btn btn-success mt-4" href="{{ route('test.create') }}" role="button">
    What's on your mind <span class="fs-5">💭</span>
</a>
"

If you are using form inputs then make sure you are using the right mehtod, action and the csrf token
example:-
"
<form 
    action="{{ route('test.index') }}"
    method="POST"
    enctype="multipart/form-data">
</form>
"
1. action is used so that we can be redirected when we submit the form after we have clicked the form button.
2. method is the type of request we are using so in this case since we don't want to show in the url what the user
   is entering so we will use the post method.
3. enctype is used when we want to upload any image file from a form to the database


"INSERTING DATA BY OOP"
"
$post = new Post();
$post->title = $request->title;
$post->excerpt = $request->excerpt;
$post->body = $request->body;
$post->image_path = 'temporary';
$post->is_published = $request->is_published === 'on';
$post->minutes_to_read = $request->minutes_to_read;
$post->save();
return redirect(route('test.index'));
"
We can store the data as shown above by creating an instance of the model and the accessing the attributes of this model
by using the arrow head and then either inserting it through the form field or by hard coded text.

We can also use the laravel's eloquent way to store data in the database
"
Post::create([
    'title' => $request->title,
    'excerpt' => $request->excerpt,
    'body' => $request->body,
    'image_path' => 'temporary',
    'is_published' => $request->is_published === 'on',
    'minutes_to_read' => $request->minutes_to_read,
]);
return redirect(route('test.index'));
"
When working with eloquent, we need to make sure that the data that the user will be filling from the form is
mass assignable and this is done by going inside the model file and using the built-in

Laravel aims to stop hijackers by changing the field values that you have defined and for that we need to use a
new property called  "protected $fillable = []"

Inside the fillable array we need to define the name attributes of our fields



"SHOWING VARIABLES IN BLADE DIRECTIVES"
We have been dumping the raw data in our blade blade file and we can see that there is a word called collection. This is
used because whenever laravel sends back multiple data at once, it is called a collection of data. This is quite useful as
we can perform actions such as methods chaining like "where()" clause or aggregated methods like "count()".

When you want to show a specific data in detail the you can directly display the entire result by just calling that key that
has been set in the controller as shown below.

"
return view('blog.show', ['one' => Post::findOrFail($id)]);
"

the "one" which is the key can be directly be displayed in the blade file as the blade file has the access to this key.

"SESSIONS"

In general session allows us to save and retrive data based on keys and this is done across multiple requests and this
data is persistant which means it is saved in the backend where they can be accessed.

Laravel has ways to define a session by using Redis, memcached or other. The sessions file is stored inside the
"config/session.php". There are many options inside this file to configure your session for the project, by default
the settings are set like session driver ("SESSION_DRIVER") which is set to "file" and the session timeout
("SESSION_TIMEOUT") is set to 120 which means 120 minutes (2 hours). Then we have the encrypt where the session data
is, by default, encrypted. Next we have is the session file location where all the session data is stored, there are
a lot more data that can be found and configured.

We can use built in session methods like "put()" to store the data and "get()" to retrieve the data. Another method is
the "push()" method which pushes in new values into an exisiting array.

If you plan on using the put method again then it will override the first value as shown below:
"
Session::put('name', 'John');
Session::put('name', 'Jane');
dd(
    Session::get('name')
);
"
The result will be that the previous value will now be updated to the latest one

To avoid this we can use the push method where we first have to put the value inside an array and then push
more values inside the array.

The example below will show how this is done
"
Session::put('name', ['John']);
Session::push('name', 'Jane');
dd(
    Session::get('name')
);
"

The dump output is shown below
"
array:2 [▼
    0 => "John"
    1 => "Jane"
]
"

We also have the "has()" method which checks if the value is set or not.

The example below will show how this works

"
if (Session::has('name')) {
    dd('yes the name exists');
}
"
The dump result is true which means "yes the name exists".

We can use this with conditional statements and run different code blocks depending in the situation

To display everything we have stored in the session we just have to use the "all()" keyword, this will
display all the data and there is no need to pass the key in this.

The example below shows how and what will be the result of the "all()" method
"
Session::put('name', ['John']);
Session::put('age', [25, 28, 24]);

dd(
    Session::all()
);
"

dump result
array:5 [▼
    "_token" => "Mn7LYE0xhVEo8AjXFmrc3xnvMbIvHZhhdYp5ugS2"
    "_previous" => array:1 [▼
        "url" => "http://127.0.0.1:8000/about"
    ]
    "_flash" => array:2 [▼
        "old" => []
        "new" => []
    ]
    "name" => array:1 [▼
        0 => "John"
    ]
    "age" => array:3 [▼
        0 => 25
        1 => 28
        2 => 24
    ]
]

As we can see that both name and age has been dumped

The "_token" we see is known as the CSRF token that we use to protect uses from Cross Site Request Forgery
What is Cross Site Request Forgery??
"
Cross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF or XSRF,
is a type of malicious exploit of a website where unauthorized commands are submitted from a user that the web
application trusts.

more about this at ----> https://en.wikipedia.org/wiki/Cross-site_request_forgery
"

The "url" is showing the previous url we were on

The "_flash" is the flash storage of laravel where we can display things like flash messages.
"
Flashing data to the session stores short-lived data and can display it in the application.
It is usually used to display status after an action. (Source is )
"

We also have the "forget()" method in which the data is going to be removed from the session storage,
this method needs just the key name

Example of "forget()" method
"
Session::forget('name');
"

The other is the session flush method which will remove all the values stored in the session when the code is
triggered.

Example of "flush()" method
"
Session::flush();
"

Laravel sets the CSRF token for us but for some reason we want to regenrate this token, we just have to use
the "regenrate()" method. Everytime this command is fired, this will always generate new CSRF token.

Example for regenerate:-
"
Session::regenerate();
dd(
    Session::all()
);
"
Every time the dump result for the token will be new and different.

For complex sessions we can store this session data inside the database.
We can use the laravel's authentication scafolding to get the idea of what is being stored in the database.

below is an example of a database migration file:-

"
Schema::create('sessions', function (Blueprint $table){
    $table->string('id')->primary();
    $table->foreignId('user_id')->nullable()->index();
    $table->string('ip_address', 45)->nullable();
    $table->text('user_agent')->nullable();
    $table->text('payload');
    $table->integer('last_activity')->index();
});
"
Breakdown:-
1. Every session will have their own unique id
2. We can also pass in the user id but it can be null or empty as well
3. The ip address is used to access this page
4. The user agent is a software that will show the content for the end users
5. The payload is a part of transmitted data
6. The last activity means that the last time the user was active on the page

Example:-
"
public function index(Request $request)
    {
        // this is just for test, there is no form for it
        $user = User::create([
            'first_name' => $request['first_name'],
            'last_name' => $request['last_name'],
            'email' => $request['email'],
            'password' => $request['password'],
        ]);
        Session::push('user', [
            'first_name' => $request['first_name'],
            'last_name' => $request['last_name'],
            'email' => $request['email'],
        ]);
        return $user;
    }
"
The session push will push the data inside the database once the user has registered and redirected to the main dashboard

If you make the model for this and then dump the output, you will find the session id, user id, ip address, user agent, payload
and the last activity

What is a user agent??
"
A user agent is a computer program representing a person, for example, a browser in a Web context.
Besides a browser, a user agent could be a bot scraping webpages, a download manager, or another app
accessing the Web.
"